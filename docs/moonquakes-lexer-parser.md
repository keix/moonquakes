# Moonquakes Lexical and Syntactic Analysis

Moonquakes includes a self-contained front-end — a lexer and parser — responsible for transforming raw Lua source code into executable bytecode (Proto).

While the virtual machine executes bytecode, the lexer and parser define what that bytecode means. They together form the compiler front-end, mirroring Lua’s clean, single-pass design.

## 1. Overview
The front-end of Moonquakes performs three main stages:

```
Lua Source → Tokens → Abstract Syntax Tree → Proto (Bytecode)
```

| Stage                | Component     | Description                                                                            |
| -------------------- | ------------- | -------------------------------------------------------------------------------------- |
| **Lexical Analysis** | `lexer.zig`   | Converts raw Lua source into a stream of tokens                                        |
| **Parsing**          | `parser.zig`  | Consumes tokens and builds an abstract syntax tree (AST)                               |
| **Code Generation**  | `codegen.zig` | Traverses the AST and emits Lua bytecode instructions (`Instruction`) within a `Proto` |


Each phase is designed to be independent and composable, so the VM and compiler remain decoupled — the compiler only needs to produce Proto structures compatible with the VM execution model.

## 2. Lexical Analysis (Lexer)

The lexer converts raw Lua source text into a stream of tokens — atomic units like identifiers, keywords, literals, and punctuation.

### 2.1 Token Structure
```
pub const Token = struct {
    kind: TokenKind,
    lexeme: []const u8,
    line: usize,
};
```

### 2.2 Token Kinds
```
pub const TokenKind = enum {
    Identifier,
    Number,
    String,
    Keyword,
    Symbol,
    Eof,
};
```

Internally, the lexer scans the input buffer character by character, classifying sequences:

| Example   | Token Kind | Lexeme    |
| --------- | ---------- | --------- |
| `local`   | Keyword    | `"local"` |
| `x`       | Identifier | `"x"`     |
| `=`       | Symbol     | `"="`     |
| `42`      | Number     | `"42"`    |
| `"hello"` | String     | `"hello"` |

### 2.3 Responsibilities
- Skip whitespace and comments (-- single-line, --[[ multi-line ]])
- Track line numbers for error reporting
- Support Lua 5.4 literal forms (including hexadecimal and exponential notation)
- Return Eof token at the end of input

The lexer does not allocate dynamic memory — all lexemes are slices over the original source buffer.

## 3. Syntax Analysis (Parser)

The parser converts the token stream into an Abstract Syntax Tree (AST) that represents the grammatical structure of the program.

### 3.1 Parsing Strategy

Moonquakes adopts a recursive descent parser, similar to the original Lua implementation. It’s small, explicit, and easy to follow — no parser generators are used.

Example grammar excerpt (simplified):

```
chunk     ::= { stat [';'] } [ laststat [';'] ]
stat      ::= varlist '=' explist | functioncall | do block end | while exp do block end
exp       ::= nil | false | true | Number | String | function | prefixexp | tableconstructor | exp binop exp | unop exp
```

Each grammar rule corresponds to a Zig function:

```
fn parseExp(self: *Parser) !*AstNode { ... }
fn parseStat(self: *Parser) !*AstNode { ... }
fn parseChunk(self: *Parser) !*AstNode { ... }
```

### 3.2 AST Structure
```
pub const AstNode = struct {
    kind: AstKind,
    left: ?*AstNode,
    right: ?*AstNode,
    value: ?TValue,
};
```


Each node corresponds to a Lua construct:

- Binary expressions (ADD, SUB, etc.)
- Unary expressions (NOT, UNM)
- Control flow (IF, WHILE, FOR)
- Function definitions and calls

## 4. Code Generation

After parsing, the AST is traversed to emit bytecode.
Each node maps directly to one or more VM instructions (Instruction), forming a Proto.

Example:

| Lua Source  | Generated Bytecode                                          |
| ----------- | ----------------------------------------------------------- |
| `x = 1 + 2` | `LOADK R0 K1`, `LOADK R1 K2`, `ADD R2 R0 R1`, `SETVAR R2 x` |


This step constructs:

- Proto.code → array of encoded instructions
- Proto.k → constant table for literals
- Proto.maxstacksize → number of registers needed

The resulting Proto can be directly passed to the VM’s execute() function.

## 5. Design Philosophy
Lua’s original compiler front-end is famously simple yet expressive. Moonquakes aims to preserve this quality, with a few guiding principles:

- Transparency: all syntax rules and code emission are explicit in Zig
- Zero Allocation: wherever possible, parse without heap allocation
- Single Pass: lexical and syntactic analysis proceed in a predictable flow
- Compatibility: follows Lua 5.4 grammar closely to ensure identical behavior

## 6. Future Work
Feature	Status	Notes

| Feature                              |  Notes                                       |
| ------------------------------------ |  ------------------------------------------- |
| Full expression grammar              |  partial arithmetic ops implemented          |
| Function definitions                 |  prototype emission planned                  |
| Local/global scope resolution        |  identifier tables in progress               |
| String interpolation / long brackets |  handled by lexer                            |
| Error recovery                       |  planned: panic-free parser with diagnostics |

## 7. Example Flow
```
Source:
    for i = 1, 3 do
        print(i)
    end

Pipeline:
    [Lexer] → FOR, Identifier(i), '=', Number(1), ',', Number(3), DO, ...
    [Parser] → Ast.For( init=1, limit=3, body=Call("print", i) )
    [Codegen] → Proto with FORPREP, FORLOOP, CALL, RETURN
    [VM] → executes Proto until RETURN
```
